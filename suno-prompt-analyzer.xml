This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.log, **/cache/**, **/tmp/**, /node_modules, /.pnp, .pnp.js, /coverage, /.next/, /out/, /build, .DS_Store, *.pem, .vercel, *.tsbuildinfo, next-env.d.ts, .npm, .eslintcache, .svelte-kit/, **/.vitepress/dist, **/.vitepress/cache, *icon0.svg, vite.config.js.timestamp-*, src/app/icon0.svg, vite.config.ts.timestamp-*, !.env*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
analyzer.py
app.py
data_loader.py
data/suno_logic.json
visualizer.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="analyzer.py">
# suno-prompt-analyzer/analyzer.py

import math
import re
import networkx as nx
from itertools import combinations
from collections import defaultdict
from typing import List, Set, Dict, Any, Optional

# --- Constants ---
PRIMARY_NODE_COLOR = "#FF6347"  # Tomato
SECONDARY_NODE_COLOR = "#4682B4"  # SteelBlue
TERTIARY_NODE_COLOR = "#D3D3D3"  # LightGray
BRIDGE_NODE_COLOR = "#32CD32"  # LimeGreen
ACRONYMS = {"r&b", "k-pop", "j-pop", "edm"}  # Styles to be fully uppercased

# --- Prompt Starter Kit Constants (Optimized) ---
MOOD_KEYWORDS = {
    "aggressive",
    "ambient",
    "anthemic",
    "atmospheric",
    "chill",
    "cinematic",
    "dark",
    "dramatic",
    "dreamy",
    "deep",
    "emotional",
    "energetic",
    "epic",
    "ethereal",
    "futuristic",
    "groovy",
    "heartfelt",
    "intense",
    "melancholic",
    "mellow",
    "powerful",
    "psychedelic",
    "romantic",
    "sad",
    "smooth",
    "uplifting",
    "upbeat",
}
INSTRUMENT_KEYWORDS = {"guitar", "piano", "synth", "bass", "drum", "violin", "electric guitar", "acoustic guitar", "orchestral", "flute"} # Complete
VOCAL_KEYWORDS = {"male voice", "female voice", "male vocals", "female vocals", "vocaloid", "female singer", "opera", "gospel"}
PRODUCTION_PROMPT = "The production is modern and clean with studio-grade fidelity and exceptional warmth and clarity and no harsh highs."

# --- Helper Functions ---
def format_label(style: str) -> str:
    return style.upper() if style in ACRONYMS else style.title()

def create_annotated_prompt_html(prompt_text: str, recognized_keywords: List[str], co_occurrence_data: Dict) -> str:
    """
    Generates an HTML string of the prompt with keywords highlighted and tooltips.
    """
    sorted_keywords = sorted(recognized_keywords, key=len, reverse=True)
    annotated_html = prompt_text
    
    for keyword in sorted_keywords:
        top_associations = co_occurrence_data.get(keyword, {})
        if top_associations:
            sorted_assocs = sorted(top_associations.items(), key=lambda x: x[1], reverse=True)[:4]
            tooltip_content = "&#10;".join([f"• {format_label(style)}: {weight:,}" for style, weight in sorted_assocs])
        else:
            tooltip_content = "No direct associations found."

        replacement_html = (
            f'<span class="highlight-keyword" data-tooltip="{tooltip_content}">'
            f'{keyword}'
            f'</span>'
        )
        pattern = re.compile(r'\b(' + re.escape(keyword) + r')\b(?![^<]*>)', re.IGNORECASE)
        annotated_html = pattern.sub(replacement_html, annotated_html)
        
    return annotated_html.replace("\n", "<br>")

# --- Core Logic Functions ---
def extract_keywords(prompt_text: str, valid_styles_set: Set[str]) -> List[str]:
    lower_prompt = prompt_text.lower()
    found_keywords = set()
    for style in valid_styles_set:
        # Use regex with word boundaries (\b) for precise matching
        if re.search(r'\b' + re.escape(style) + r'\b', lower_prompt):
            found_keywords.add(style)
    return sorted(list(found_keywords))

def calculate_influence_scores(keywords: List[str], co_occurrence_data: Dict) -> Dict[str, float]:
    influence_scores = defaultdict(float)
    for keyword in keywords:
        if keyword in co_occurrence_data:
            for associated_style, weight in co_occurrence_data[keyword].items():
                influence_scores[associated_style] += float(weight)
    return influence_scores

def calculate_cohesion(keywords: List[str], co_occurrence_data: Dict) -> float:
    if len(keywords) < 2:
        return 100.0
    connected_pairs = 0
    total_pairs = list(combinations(keywords, 2))
    for kw1, kw2 in total_pairs:
        if kw2 in co_occurrence_data.get(kw1, {}) or kw1 in co_occurrence_data.get(kw2, {}):
            connected_pairs += 1
    return (connected_pairs / len(total_pairs)) * 100.0 if total_pairs else 100.0

# --- Suggestion Engine ---
def generate_suggestions(cohesion_score: float, recognized_keywords: List[str], sorted_influences: List, co_occurrence_data: Dict) -> Dict:
    # Return a structured dictionary for richer UI rendering
    suggestion = {"title": "", "type": "info", "body": {}}

    # Scenario A: Low Cohesion - The Mediator & Tutor
    if cohesion_score < 40 and len(recognized_keywords) > 1:
        suggestion["title"] = "Low Cohesion Detected"
        suggestion["type"] = "error"
        
        G = nx.Graph()
        G.add_nodes_from(recognized_keywords)
        for kw1, kw2 in combinations(recognized_keywords, 2):
            if co_occurrence_data.get(kw1, {}).get(kw2): G.add_edge(kw1, kw2)
        factions = sorted(list(nx.connected_components(G)), key=len, reverse=True)

        if len(factions) > 1:
            faction_a, faction_b = factions[0], factions[1]
            
            # Strategy 1: Bridge the Gap
            bridge_candidates = {style for style, score in sorted_influences[:50]}
            bridge_scores = {}
            for candidate in bridge_candidates:
                affinity_a = sum(co_occurrence_data.get(kw, {}).get(candidate, 0) for kw in faction_a)
                affinity_b = sum(co_occurrence_data.get(kw, {}).get(candidate, 0) for kw in faction_b)
                if affinity_a > 0 and affinity_b > 0: bridge_scores[candidate] = affinity_a * affinity_b
            
            top_bridges = sorted(bridge_scores.items(), key=lambda x: x[1], reverse=True)[:3]

            # Strategy 2: Strengthen the Core
            # Identify the keywords in the smaller faction as candidates for removal/replacement
            conflict_keywords = faction_b
            # Suggest replacements by finding keywords related to the main faction
            main_faction_reinforcements = {
                style for kw in faction_a for style in co_occurrence_data.get(kw, {})
                if style not in recognized_keywords
            }
            replacement_suggestions = sorted(main_faction_reinforcements)[:3]

            suggestion["body"] = {
                "intro": f"Your prompt has two distinct stylistic groups:",
                "clusters": [list(faction_a), list(faction_b)],
                "strategies": {
                    "Bridge the Gap (Create a Fusion)": [f"Add `{bridge[0]}` to connect your ideas." for bridge in top_bridges],
                    "Strengthen the Core (Focus)": [f"Consider replacing `{kw}` with terms like `{', '.join(replacement_suggestions)}`." for kw in conflict_keywords]
                }
            }
            return suggestion

    # Scenario B: High Cohesion - The Reinforcer
    elif cohesion_score >= 75:
        suggestion["title"] = "Excellent Cohesion!"
        suggestion["type"] = "success"
        reinforcement_candidates = [style for style, score in sorted_influences[:7]]
        if reinforcement_candidates:
            suggestion["body"] = {
                "intro": "To make your prompt even more focused, consider adding these highly-related keywords:",
                "suggestions": [f"`{r}`" for r in reinforcement_candidates[:3]]
            }
        return suggestion

    # Scenario C: Moderate Cohesion or other cases - The Observer
    else:
        suggestion["title"] = "Moderate Cohesion"
        suggestion["type"] = "warning"
        suggestion["body"] = {
            "intro": "This can lead to unique genre fusions. If the results aren't what you expect, try adding more specific, related terms to guide the AI."
        }
        return suggestion

def analyze_explorer_styles(primary_style: str, secondary_style: Optional[str], co_occurrence_data: Dict) -> Dict:
    """
    Analyzes one or two styles for the Style Explorer mode.
    If a secondary style is provided, it performs a fusion analysis.
    """
    if not secondary_style:
        # --- SINGLE STYLE ANALYSIS (Original Logic) ---
        direct_associations = co_occurrence_data.get(primary_style, {})
        sorted_assocs = sorted(direct_associations.items(), key=lambda x: x[1], reverse=True)
        
        bar_chart_data = {
            style: math.log10(score + 1) for style, score in sorted_assocs[:15]
        }

        nodes, edges, node_ids = [], [], set()
        nodes.append({"id": primary_style, "label": format_label(primary_style), "size": 30, "color": PRIMARY_NODE_COLOR, "title": f"Selected Style: {format_label(primary_style)}"})
        node_ids.add(primary_style)

        first_degree_nodes = sorted_assocs[:7]
        for style, weight in first_degree_nodes:
            if style not in node_ids:
                nodes.append({"id": style, "label": format_label(style), "size": 18, "color": SECONDARY_NODE_COLOR, "title": f"Direct Association Strength: {weight:,}"})
                node_ids.add(style)
            edges.append({"from": primary_style, "to": style, "value": math.log10(weight + 1) * 2, "title": f"Association Strength: {weight:,}"})

        for first_degree_style, _ in first_degree_nodes:
            second_degree_assocs = sorted(co_occurrence_data.get(first_degree_style, {}).items(), key=lambda x: x[1], reverse=True)[:2]
            for second_degree_style, weight in second_degree_assocs:
                if second_degree_style not in node_ids:
                    nodes.append({"id": second_degree_style, "label": format_label(second_degree_style), "size": 10, "color": TERTIARY_NODE_COLOR, "title": f"Second-Degree Association Strength: {weight:,}"})
                    node_ids.add(second_degree_style)
                if second_degree_style in node_ids:
                     edges.append({"from": first_degree_style, "to": second_degree_style, "value": math.log10(weight + 1), "title": f"Association Strength: {weight:,}"})

        graph_data = {"nodes": nodes, "edges": edges}

        top_associated_styles = [style for style, score in sorted_assocs[:15]]
        genre_associates = [style for style, score in sorted_assocs[:3]]
        genre_prompt = f"A powerful and modern {primary_style} anthem"
        if len(genre_associates) == 1: genre_prompt += f" that draws heavy influence from {genre_associates[0]}."
        elif len(genre_associates) == 2: genre_prompt += f" that draws heavy influence from {genre_associates[0]} and incorporates the driving energy of {genre_associates[1]}."
        elif len(genre_associates) >= 3: genre_prompt += f" that draws heavy influence from {genre_associates[0]} and incorporates the driving energy of {genre_associates[1]} and the melodic structure of {genre_associates[2]}."
        else: genre_prompt += "."

        found_moods = [mood for mood in top_associated_styles if mood in MOOD_KEYWORDS]
        if len(found_moods) >= 2: mood_prompt = f"The overall mood is {found_moods[0]} and intensely {found_moods[1]} building throughout the track."
        elif len(found_moods) == 1: mood_prompt = f"The overall mood is deeply {found_moods[0]} and builds in intensity throughout the track."
        else: mood_prompt = "The track has an emotionally resonant and dynamic feel that builds in intensity."

        found_instruments = [inst for inst in top_associated_styles if inst in INSTRUMENT_KEYWORDS]
        inst_priority = ['guitar', 'electric guitar', 'acoustic guitar', 'synth', 'piano', 'bass', 'drum', 'orchestral', 'violin', 'flute']
        sorted_instruments = sorted(found_instruments, key=lambda x: inst_priority.index(x) if x in inst_priority else len(inst_priority))[:3]
        if len(sorted_instruments) >= 3: instrument_prompt = f"The instrumentation is centered around a powerful {sorted_instruments[0]} and driving {sorted_instruments[1]} with a crisp {sorted_instruments[2]} section."
        elif len(sorted_instruments) == 2: instrument_prompt = f"The instrumentation prominently features a lush {sorted_instruments[0]} and a solid {sorted_instruments[1]} rhythm."
        elif len(sorted_instruments) == 1: instrument_prompt = f"A prominent {sorted_instruments[0]} carries the main melody."
        else: instrument_prompt = "The track features a rich and layered instrumentation with a strong rhythmic foundation."

        found_vocals = [vocal for vocal in top_associated_styles if vocal in VOCAL_KEYWORDS]
        if found_vocals:
            vocal_style = found_vocals[0].replace(" voice", "").replace(" vocals", "").replace(" singer", "")
            vocal_prompt = f"A powerful {vocal_style} voice leads the track, supported by rich layered background harmonies."
        else: vocal_prompt = "Featuring clear and expressive lead vocals with rich layered background harmonies."
            
        prompt_starter_text = " ".join([genre_prompt, mood_prompt, instrument_prompt, vocal_prompt, PRODUCTION_PROMPT])

    else:
        # --- FUSION ANALYSIS ---
        assocs_a = co_occurrence_data.get(primary_style, {})
        assocs_b = co_occurrence_data.get(secondary_style, {})
        
        # 1. Bar Chart Data (with Synergy Boost)
        combined_scores = defaultdict(float)
        all_keys = set(assocs_a.keys()) | set(assocs_b.keys())
        for key in all_keys:
            score_a = assocs_a.get(key, 0)
            score_b = assocs_b.get(key, 0)
            combined_scores[key] = score_a + score_b
            # Synergy Boost for shared associates
            if score_a > 0 and score_b > 0:
                combined_scores[key] *= 1.5

        sorted_combined_assocs = sorted(combined_scores.items(), key=lambda x: x[1], reverse=True)
        bar_chart_data = {style: math.log10(score + 1) for style, score in sorted_combined_assocs[:15]}
        
        # 2. Network Graph Data
        nodes, edges, node_ids = [], [], set()
        top_assocs_a = {style for style, score in sorted(assocs_a.items(), key=lambda x:x[1], reverse=True)[:15]}
        top_assocs_b = {style for style, score in sorted(assocs_b.items(), key=lambda x:x[1], reverse=True)[:15]}
        bridge_nodes = top_assocs_a.intersection(top_assocs_b)

        # Add Primary Nodes
        for style in [primary_style, secondary_style]:
            nodes.append({"id": style, "label": format_label(style), "size": 30, "color": PRIMARY_NODE_COLOR, "title": f"Primary Style: {format_label(style)}"})
            node_ids.add(style)

        # Add Associated Nodes (Top 7 from each primary style)
        for source_style, assocs in [(primary_style, assocs_a), (secondary_style, assocs_b)]:
            top_7 = sorted(assocs.items(), key=lambda x: x[1], reverse=True)[:7]
            for assoc_style, weight in top_7:
                if assoc_style not in node_ids:
                    is_bridge = assoc_style in bridge_nodes
                    node_color = BRIDGE_NODE_COLOR if is_bridge else SECONDARY_NODE_COLOR
                    title_prefix = "Bridge Style" if is_bridge else "Direct Association"
                    nodes.append({"id": assoc_style, "label": format_label(assoc_style), "size": 18, "color": node_color, "title": f"{title_prefix}: {format_label(assoc_style)}<br>Strength: {weight:,}"})
                    node_ids.add(assoc_style)
                edges.append({"from": source_style, "to": assoc_style, "value": math.log10(weight + 1) * 2, "title": f"Association Strength: {weight:,}"})

        graph_data = {"nodes": nodes, "edges": edges}

        # 3. Prompt Starter Kit for Fusions
        top_associated_styles = [style for style, score in sorted_combined_assocs[:20]]

        # -- Part 1: Genre Prompt --
        top_bridge = next((style for style in [s for s, _ in sorted_combined_assocs] if style in bridge_nodes and style not in MOOD_KEYWORDS), None)
        genre_prompt = f"A compelling and cinematic fusion of {primary_style} and {secondary_style}, combining the core characteristics of both genres."
        if top_bridge:
            genre_prompt = f"A compelling fusion of {primary_style} and {secondary_style}, combining the raw energy of {primary_style} with the intricate textures of {secondary_style}, grounded in a shared influence of {top_bridge}."
        else:
            genre_prompt = f"An experimental and highly contrasting fusion of {primary_style} and {secondary_style}, aiming to blend their distinct soundscapes into a novel composition."

        # -- Part 2: Mood Prompt --
        moods_a = {mood for mood in top_assocs_a if mood in MOOD_KEYWORDS}
        moods_b = {mood for mood in top_assocs_b if mood in MOOD_KEYWORDS}
        shared_moods = list(moods_a.intersection(moods_b))
        unique_moods_a = list(moods_a - moods_b)
        unique_moods_b = list(moods_b - moods_a)

        if shared_moods:
            mood_prompt = f"The mood is intensely {shared_moods[0]}, drawing its power from both genres."
        elif unique_moods_a and unique_moods_b:
            mood_prompt = f"The track's mood is a unique contrast, blending the {unique_moods_a[0]} edge of {primary_style} with the {unique_moods_b[0]} atmosphere of {secondary_style}."
        else: # Fallback
            mood_prompt = "The track has an emotionally resonant and dynamic feel that builds in intensity."

        # -- Part 3: Instrumentation Prompt --
        inst_priority = ['guitar', 'electric guitar', 'acoustic guitar', 'synth', 'piano', 'bass', 'drum', 'orchestral', 'violin', 'flute']
        instruments_a = sorted([inst for inst in top_assocs_a if inst in INSTRUMENT_KEYWORDS], key=lambda x: inst_priority.index(x) if x in inst_priority else len(inst_priority))[:2]
        instruments_b = sorted([inst for inst in top_assocs_b if inst in INSTRUMENT_KEYWORDS], key=lambda x: inst_priority.index(x) if x in inst_priority else len(inst_priority))[:2]
        combined_instruments = list(dict.fromkeys(instruments_a + instruments_b)) # Get unique instruments, preserving order

        if len(combined_instruments) >= 3:
            inst1, inst2, inst3 = combined_instruments[0], combined_instruments[1], combined_instruments[2]
            instrument_prompt = f"The instrumentation is a rich hybrid, centered around {inst1} and {inst2} from both styles, with a solid {inst3} foundation."
        elif len(combined_instruments) == 2:
            instrument_prompt = f"The instrumentation blends the {combined_instruments[0]} from {primary_style} with the {combined_instruments[1]} from {secondary_style}."
        else: # Fallback
            instrument_prompt = "The track features a rich and layered instrumentation with a strong rhythmic foundation."

        # -- Part 4: Vocal Prompt --
        vocals_a = [vocal for vocal in top_assocs_a if vocal in VOCAL_KEYWORDS]
        vocals_b = [vocal for vocal in top_assocs_b if vocal in VOCAL_KEYWORDS]

        if vocals_a:
            primary_vocal_style = vocals_a[0].replace(" voice", "").replace(" vocals", "").replace(" singer", "")
            if vocals_b and vocals_b[0] != vocals_a[0]:
                secondary_vocal_style = vocals_b[0].replace(" voice", "").replace(" vocals", "").replace(" singer", "")
                vocal_prompt = f"Featuring a powerful {primary_vocal_style} lead vocal, with ethereal {secondary_vocal_style} vocals providing soaring background harmonies."
            else:
                vocal_prompt = f"A powerful {primary_vocal_style} voice leads the track, supported by rich layered background harmonies."
        else: # Fallback
            vocal_prompt = "Featuring clear and expressive lead vocals with rich layered background harmonies."

        # -- Part 5: Assemble --
        prompt_starter_text = " ".join([genre_prompt, mood_prompt, instrument_prompt, vocal_prompt, PRODUCTION_PROMPT])

    return {
        "bar_chart_data": bar_chart_data,
        "graph_data": graph_data,
        "prompt_starter_text": prompt_starter_text,
    }
# --- Main Orchestrator ---
def prepare_analysis_results(prompt_text: str, negative_prompt_text: str, default_styles: Set[str], co_occurrence_data: Dict) -> Dict[str, Any]:
    positive_keywords = extract_keywords(prompt_text, default_styles)
    negative_keywords = extract_keywords(negative_prompt_text, default_styles)
    negative_keywords_set = set(negative_keywords)

    # Ensure keywords are not in both positive and negative lists (negative wins)
    positive_keywords = [kw for kw in positive_keywords if kw not in negative_keywords_set]

    if not positive_keywords:
        return {"recognized_keywords": [], "error": "No valid Suno styles were found in the prompt."}

    # 1. Analyze the positive prompt in its original state
    base_influence_scores = calculate_influence_scores(positive_keywords, co_occurrence_data)
    cohesion_score = calculate_cohesion(positive_keywords, co_occurrence_data)
    annotated_html = create_annotated_prompt_html(prompt_text, positive_keywords, co_occurrence_data)

    base_normalized_scores = {
        style: math.log10(score + 1)
        for style, score in base_influence_scores.items()
        if style not in positive_keywords
    }
    base_sorted_influences = sorted(base_normalized_scores.items(), key=lambda item: item[1], reverse=True)

    # 3. Apply the "Repulsive Force" from negative keywords
    penalized_influence_scores = base_influence_scores.copy()
    penalty_factor = 0.1  # 90% reduction
    tainted_styles = set()
    for neg_kw in negative_keywords:
        # Taint the top 5 closest associates of each negative keyword
        top_associates = sorted(co_occurrence_data.get(neg_kw, {}).items(), key=lambda x: x[1], reverse=True)[:5]
        for style, weight in top_associates:
            tainted_styles.add(style)

    for style in tainted_styles:
        if style in penalized_influence_scores:
            penalized_influence_scores[style] *= penalty_factor
    for neg_kw in negative_keywords:
        if neg_kw in penalized_influence_scores:
            penalized_influence_scores[neg_kw] = 0

    normalized_scores = {
        style: math.log10(score + 1)
        for style, score in penalized_influence_scores.items()
        if style not in positive_keywords and style not in negative_keywords_set
    }
    
    sorted_influences = sorted(normalized_scores.items(), key=lambda item: item[1], reverse=True)
    top_10_fingerprint = dict(sorted_influences[:10]) # Bug Fix: Changed from top_20 to top_10

    # 4. Generate suggestions based on the final, penalized data
    suggestion = generate_suggestions(cohesion_score, positive_keywords, sorted_influences, co_occurrence_data)
    
    nodes, edges = [], []
    node_ids = set()
    top_associated_styles_for_graph = {style for style, score in sorted_influences[:20]}

    for keyword in positive_keywords:
        if keyword not in node_ids:
            nodes.append({"id": keyword, "label": format_label(keyword), "size": 25, "color": PRIMARY_NODE_COLOR, "title": f"Your Keyword: {format_label(keyword)}"})
            node_ids.add(keyword)

    min_log_score = sorted_influences[9][1] if len(sorted_influences) > 9 else 1
    max_log_score = sorted_influences[0][1] if sorted_influences else 1

    for style, score in sorted_influences:
        if style in top_associated_styles_for_graph and style not in node_ids:
            size_ratio = (score - min_log_score) / (max_log_score - min_log_score) if max_log_score > min_log_score else 0
            node_size = 12 + (8 * size_ratio)
            nodes.append({"id": style, "label": format_label(style), "size": node_size, "color": SECONDARY_NODE_COLOR, "title": f"Penalized Influence Score: {penalized_influence_scores.get(style, 0):,.0f}"})
            node_ids.add(style)

    for keyword in positive_keywords:
        for associated_style, weight in co_occurrence_data.get(keyword, {}).items():
            if associated_style in node_ids and associated_style != keyword and associated_style not in negative_keywords_set:
                edges.append({"from": keyword, "to": associated_style, "value": math.log10(weight + 1), "title": f"Association Strength: {weight:,}"})

    return {
        "recognized_keywords": positive_keywords, # Renamed for backward compatibility with UI
        "negative_keywords": negative_keywords,
        "cohesion_score": cohesion_score,
        "fingerprint": top_10_fingerprint,
        "graph_data": {"nodes": nodes, "edges": edges},
        "annotated_html": annotated_html,
        "suggestion": suggestion,
    }
</file>

<file path="app.py">
# suno-prompt-analyzer/app.py

import streamlit as st
import streamlit.components.v1 as components
from pathlib import Path

# Import our custom modules
from data_loader import load_suno_data
from analyzer import prepare_analysis_results, analyze_explorer_styles, format_label
from visualizer import create_ranked_bar_chart, create_association_map

# --- 1. PAGE CONFIGURATION ---
st.set_page_config(page_title="Suno Prompt Analyzer", layout="wide", initial_sidebar_state="collapsed")

# --- 2. DATA LOADING ---
DATA_FILE_PATH = Path(__file__).parent / "data" / "suno_logic.json"
DEFAULT_STYLES, CO_OCCURRENCE_DATA = load_suno_data(DATA_FILE_PATH)

# --- 3. UI LAYOUT ---
st.title("🎵 Suno Prompt Analyzer")
st.markdown("Enter your Suno style prompt to visualize its underlying stylistic connections and discover its 'gravitational pull'.")
st.divider()

# Initialize session state for persistent prompt text ONCE
if 'prompt_text' not in st.session_state:
    st.session_state.prompt_text = "A powerful acoustic folk ballad in a minor key with a deeply reflective and intimate feel and a slow and deliberate adagio tempo. The primary instrumentation is a clean fingerpicked acoustic guitar playing intricate arpeggiated chords with a mournful cello providing sustained counter-melodies, a subtle atmospheric string section, and a sparse piano adding depth and flowing texture. The production features modern professional mastering with studio-grade fidelity, exceptional warmth and clarity, a natural reverb on the instruments, and a clean mix with no harsh highs. Powerful, increasingly intense and epic. Professional mastering."

tab1, tab2 = st.tabs(["**Prompt Analyzer**", "**Style Explorer**"])

with tab1:
    # --- PROMPT ANALYZER MODE ---
    st.header("Analyze a Full Prompt")

    with st.form(key='prompt_form'):
        prompt_text_input = st.text_area(
            "Enter your prompt here:",
            value=st.session_state.prompt_text,
            height=150,
        )
        negative_prompt_input = st.text_input(
            "Negative Keywords (comma-separated):",
            placeholder="e.g., rock, pop, guitar",
            help="Keywords to exclude and steer the model away from."
        )
        submit_button = st.form_submit_button(label='Analyze Prompt')

    if submit_button:
        st.session_state.prompt_text = prompt_text_input
        if prompt_text_input:
            analysis_results = prepare_analysis_results(
                prompt_text_input, negative_prompt_input, DEFAULT_STYLES, CO_OCCURRENCE_DATA
            )
            st.session_state.analysis_results = analysis_results
        else:
            st.warning("Please enter a prompt to analyze.")
            st.session_state.analysis_results = None

    if 'analysis_results' in st.session_state and st.session_state.analysis_results:
        results = st.session_state.analysis_results
        st.divider()

        if results.get("error"):
            st.error(results["error"])
        else:
            col1, col2 = st.columns([1, 2])
            with col1:
                st.subheader("Interactive Prompt Inspector")
                inspector_css = """
                <style>
                    .highlight-keyword { background-color: rgba(255, 127, 80, 0.3); border-radius: 4px; padding: 2px 4px; position: relative; cursor: pointer; }
                    .highlight-keyword:hover::after { content: attr(data-tooltip); position: absolute; left: 0; top: 120%; z-index: 100; background-color: #222; color: #fff; border: 1px solid #444; border-radius: 5px; padding: 10px; font-family: monospace; font-size: 0.9em; white-space: pre-wrap; min-width: 250px; text-align: left; }
                    .neg-tag { display: inline-block; background-color: #400; color: #f88; padding: 4px 8px; margin: 2px; border-radius: 5px; font-family: monospace; font-size: 0.9em; }
                    .tag { display: inline-block; background-color: #334; color: #afa; padding: 4px 8px; margin: 2px; border-radius: 5px; font-family: monospace; font-size: 0.9em; }
                </style>
                """
                st.markdown(inspector_css + f"<div style='border: 1px solid #333; padding: 10px; border-radius: 5px;'>{results['annotated_html']}</div>", unsafe_allow_html=True)
                
                st.metric(label="Keyword Cohesion Score", value=f"{results['cohesion_score']:.1f} / 100", help="Measures how strongly your keywords are related. Higher is better.")
                score = results['cohesion_score']
                if score >= 75: st.success("✓ Excellent Cohesion")
                elif score >= 40: st.warning("! Moderate Cohesion")
                else: st.error("✗ Low Cohesion")
                
                if results['negative_keywords']:
                    st.markdown("<b>Applied Negative Keywords</b>", unsafe_allow_html=True)
                    neg_keywords_html = "".join([f"<span class='neg-tag'>{kw}</span>" for kw in results['negative_keywords']])
                    st.markdown(neg_keywords_html, unsafe_allow_html=True)
                
                st.divider()
                st.subheader("🤖 Prompt Co-Pilot")
                suggestion = results.get("suggestion")
                if suggestion:
                    with st.expander(f"{suggestion['title']}", expanded=True):
                        body = suggestion.get('body', {})
                        if body.get('intro'): st.write(body['intro'])
                        if body.get('clusters'):
                            for i, cluster in enumerate(body['clusters']):
                                cluster_html = "".join([f"<span class='tag'>{kw}</span>" for kw in cluster])
                                st.markdown(f"**Cluster {i+1}:** {cluster_html}", unsafe_allow_html=True)
                        if body.get('strategies'):
                            for title, points in body['strategies'].items():
                                st.markdown(f"--- \n**{title}**")
                                for point in points: st.markdown(f"- {point}")
                        elif body.get('suggestions'): st.markdown(" ".join(body['suggestions']))

            with col2:
                st.subheader("Stylistic Fingerprint")
                fingerprint_fig = create_ranked_bar_chart(
                    results['fingerprint'], "Top 10 Stylistic Influences", "Normalized Influence Score (log scale)"
                )
                st.plotly_chart(fingerprint_fig, use_container_width=True)

                st.divider()
                st.subheader("Interactive Association Map")
                edge_threshold = st.slider(
                    "Minimum Connection Strength (log scale):", min_value=0.0, max_value=15.0, value=7.0, step=0.5,
                    help="Hides weaker connections to declutter the graph.", key="analyzer_edge_slider"
                )
                filtered_graph_data = results['graph_data'].copy()
                filtered_graph_data['edges'] = [edge for edge in filtered_graph_data['edges'] if edge['value'] >= edge_threshold]
                network_graph = create_association_map(filtered_graph_data)
                html_content = network_graph.generate_html()
                components.html(html_content, height=620, scrolling=True)

with tab2:
    # --- STYLE EXPLORER MODE ---
    st.header("Explore a Single Style")
    st.markdown("Select a single keyword to discover its closest associations, explore its stylistic neighborhood, and get a pre-built prompt starter kit.")

    all_styles_sorted = sorted(list(DEFAULT_STYLES))
    col1_exp, col2_exp = st.columns(2)
    with col1_exp:
        primary_style = st.selectbox(
            "**Primary Style:**",
            options=all_styles_sorted,
            index=None,
            placeholder="Search for a primary style..."
        )
    with col2_exp:
        secondary_style = None
        if primary_style:
            secondary_options = [""] + [s for s in all_styles_sorted if s != primary_style]
            secondary_style = st.selectbox(
                "**Secondary Style (for fusion):**",
                options=secondary_options,
                index=0,
                placeholder="Select a style to blend... (Optional)"
            )
            if secondary_style == "": secondary_style = None

    if primary_style:
        explorer_results = analyze_explorer_styles(primary_style, secondary_style, CO_OCCURRENCE_DATA)
        st.divider()

        col1, col2 = st.columns(2)
        with col1:
            chart_title = f"Top Associations for '{format_label(primary_style)}'"
            if secondary_style:
                chart_title += f" & '{format_label(secondary_style)}' Fusion"
            st.subheader(chart_title)
            bar_fig = create_ranked_bar_chart(explorer_results['bar_chart_data'], chart_title, "Normalized Association Strength (log scale)")
            st.plotly_chart(bar_fig, use_container_width=True)

            st.subheader("📝 Prompt Starter Kit")
            st.info("Copy the prompt below as a starting point for your creation.")
            st.code(explorer_results['prompt_starter_text'], language='text')

        with col2:
            st.subheader("Association Constellation")
            explorer_graph = create_association_map(explorer_results['graph_data'])
            html_content = explorer_graph.generate_html()
            components.html(html_content, height=620, scrolling=True)
</file>

<file path="data_loader.py">
# suno-prompt-analyzer/data_loader.py

import json
from typing import Tuple, Set, Dict, Any
import streamlit as st

# Use Streamlit's caching to load the data only once.
@st.cache_data
def load_suno_data(path: str) -> Tuple[Set[str], Dict[str, Any]]:
    """
    Loads, parses, and prepares the Suno style data from a JSON file.

    This function is cached, so the data is loaded from disk only once per
    session, ensuring optimal performance.

    Args:
        path: The file path to the suno_logic.json file.

    Returns:
        A tuple containing:
        - A set of all default style strings for fast lookups.
        - A dictionary of the co-occurrence data.
    
    Raises:
        FileNotFoundError: If the file at the specified path does not exist.
        ValueError: If the file is not a valid JSON or lacks expected keys.
    """
    try:
        with open(path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        # For fast keyword checking (O(1) average time complexity)
        default_styles_set = set(data["default_styles"])
        co_occurrence_dict = data["co_existing_styles_dict"]

        if not default_styles_set or not co_occurrence_dict:
            raise ValueError("JSON file is missing 'default_styles' or 'co_existing_styles_dict' keys.")

        return default_styles_set, co_occurrence_dict

    except FileNotFoundError:
        st.error(f"FATAL: Data file not found at '{path}'. Please make sure 'suno_logic.json' is in the 'data' subfolder.")
        st.stop()
    except (json.JSONDecodeError, KeyError) as e:
        st.error(f"FATAL: Error parsing the data file '{path}'. It may be corrupted or not valid JSON. Details: {e}")
        st.stop()
</file>

<file path="data/suno_logic.json">
{
"default_styles": [
"pop",
"rock",
"rap",
"metal",
"electronic",
"upbeat",
"melodic",
"dark",
"piano",
"hip hop",
"epic",
"bass",
"emotional",
"acoustic",
"aggressive",
"trap",
"country",
"edm",
"r&b",
"jazz",
"ballad",
"funk",
"guitar",
"hard rock",
"slow",
"synthwave",
"dance",
"folk",
"heavy metal",
"atmospheric",
"catchy",
"sad",
"indie",
"house",
"j-pop",
"dreamy",
"soul",
"punk",
"powerful",
"male voice",
"lo-fi",
"uplifting",
"female voice",
"chill",
"techno",
"ambient",
"blues",
"romantic",
"male vocals",
"reggae",
"orchestral",
"opera",
"female vocals",
"fast",
"energetic",
"vocaloid",
"drum",
"melancholic",
"intense",
"dubstep",
"alternative rock",
"emo",
"disco",
"smooth",
"experimental",
"synth",
"psychedelic",
"progressive",
"k-pop",
"mellow",
"groovy",
"80s",
"japanese",
"anthemic",
"violin",
"nu metal",
"pop rock",
"electric guitar",
"cinematic",
"classical",
"cantonese",
"heartfelt",
"ethereal",
"swing",
"electro",
"flute",
"female singer",
"grunge",
"deep",
"drum and bass",
"trance",
"indie pop",
"gospel",
"anime",
"math rock",
"90s",
"dramatic",
"industrial",
"electropop",
"phonk",
"beat",
"acoustic guitar",
"futuristic",
"bounce drop",
"mutation funk"
],
"co_existing_styles_dict": {
"rap": {
"trap": 327000000000,
"pop": 13700000000,
"bass": 1090000000,
"hip hop": 106000000,
"beat": 9400000,
"rock": 930000,
"metal": 88000,
"melodic": 6900,
"aggressive": 660,
"fast": 56
},
"melodic": {
"pop": 76000000000,
"metal": 7300000000,
"rap": 690000000,
"rock": 55000000,
"beat": 4800000,
"guitar": 460000,
"bass": 40000,
"synth": 3600,
"piano": 320,
"epic": 28
},
"hip hop": {
"rap": 106000000000,
"pop": 4500000000,
"punk": 300000000,
"trap": 27000000,
"bass": 2500000,
"r&b": 220000,
"lo-fi": 20000,
"beat": 1800,
"rock": 160,
"metal": 16
},
"r&b": {
"pop": 76000000000,
"soul": 6900000000,
"electro": 320000000,
"rap": 31000000,
"electronic": 2500000,
"funk": 240000,
"hip hop": 22000,
"smooth": 2200,
"male vocals": 200,
"jazz": 20
},
"epic": {
"metal": 91000000000,
"orchestral": 6800000000,
"rock": 660000000,
"bass": 53000000,
"drum": 5000000,
"guitar": 470000,
"pop": 37000,
"emo": 3400,
"beat": 310,
"male voice": 29
},
"opera": {
"rock": 50000000000,
"powerful": 4100000000,
"metal": 410000000,
"pop": 35000000,
"punk": 2800000,
"epic": 270000,
"80s": 22000,
"dark": 2000,
"pop rock": 170,
"melodic": 16
},
"cinematic": {
"orchestral": 33000000000,
"epic": 2700000000,
"atmospheric": 140000000,
"synth": 14000000,
"metal": 1300000,
"electronic": 110000,
"piano": 11000,
"ambient": 1100,
"electro": 110,
"dark": 10
},
"dramatic": {
"epic": 15000000000,
"rock": 1000000000,
"orchestral": 100000000,
"dark": 9000000,
"pop": 900000,
"opera": 80000,
"piano": 8000,
"bass": 800,
"guitar": 70,
"powerful": 7
},
"lo-fi": {
"chill": 35000000000,
"funk": 3400000000,
"japanese": 330000000,
"pop": 23000000,
"jazz": 2100000,
"hip hop": 200000,
"electro": 18000,
"synth": 1500,
"rock": 140,
"mellow": 13
},
"japanese": {
"funk": 37000000000,
"lo-fi": 3300000000,
"rock": 290000000,
"pop": 28000000,
"electro": 1400000,
"vocaloid": 130000,
"metal": 11000,
"anime": 1100,
"synth": 90,
"swing": 9
},
"beat": {
"upbeat": 366000000000,
"pop": 24300000000,
"bass": 940000000,
"rap": 94000000,
"synth": 7100000,
"electro": 630000,
"drum": 62000,
"rock": 5700,
"electronic": 510,
"melodic": 48
},
"rock": {
"pop": 315000000000,
"metal": 22300000000,
"hard rock": 1830000000,
"guitar": 161000000,
"punk": 12400000,
"alternative rock": 1210000,
"indie": 97000,
"rap": 9300,
"electro": 870,
"emo": 87
},
"guitar": {
"rock": 161000000000,
"drum": 13400000000,
"bass": 1260000000,
"metal": 125000000,
"electric guitar": 12000000,
"piano": 850000,
"pop": 84000,
"acoustic": 8300,
"acoustic guitar": 690,
"male voice": 64
},
"hard rock": {
"rock": 183000000000,
"metal": 8600000000,
"guitar": 370000000,
"industrial": 32000000,
"heavy metal": 2500000,
"powerful": 220000,
"bass": 19000,
"drum": 1600,
"pop": 120,
"aggressive": 12
},
"bass": {
"drum": 215000000000,
"guitar": 12600000000,
"rap": 1090000000,
"beat": 94000000,
"drum and bass": 8400000,
"pop": 810000,
"rock": 71000,
"deep": 7000,
"piano": 660,
"synth": 66
},
"male voice": {
"female voice": 167000000000,
"pop": 10200000000,
"rock": 700000000,
"guitar": 64000000,
"bass": 6000000,
"drum": 450000,
"rap": 36000,
"beat": 3500,
"deep": 350,
"piano": 32
},
"female voice": {
"male voice": 167000000000,
"pop": 5000000000,
"bass": 340000000,
"guitar": 26000000,
"rock": 2500000,
"drum": 210000,
"beat": 18000,
"punk": 1700,
"electro": 170,
"edm": 17
},
"drum": {
"bass": 215000000000,
"guitar": 13400000000,
"drum and bass": 840000000,
"rock": 75000000,
"metal": 6400000,
"beat": 620000,
"pop": 57000,
"piano": 5300,
"epic": 500,
"male voice": 45
},
"drum and bass": {
"bass": 84000000000,
"drum": 8400000000,
"electro": 130000000,
"electronic": 12000000,
"vocaloid": 1100000,
"emo": 80000,
"pop": 8000,
"experimental": 800,
"funk": 7
},
"metal": {
"rock": 223000000000,
"heavy metal": 18000000000,
"guitar": 1250000000,
"nu metal": 114000000,
"aggressive": 9500000,
"epic": 910000,
"rap": 88000,
"hard rock": 8600,
"melodic": 730,
"dark": 68
},
"heavy metal": {
"metal": 180000000000,
"rock": 4000000000,
"guitar": 320000000,
"bass": 28000000,
"drum": 2800000,
"aggressive": 280000,
"hard rock": 25000,
"powerful": 2400,
"epic": 190,
"fast": 10
},
"pop": {
"rock": 315000000000,
"electro": 26500000000,
"beat": 2430000000,
"upbeat": 197000000,
"electronic": 16200000,
"synth": 1600000,
"j-pop": 157000,
"punk": 14800,
"dance": 1450,
"indie": 137
},
"orchestral": {
"epic": 68000000000,
"cinematic": 3300000000,
"emo": 320000000,
"emotional": 30000000,
"drum": 2600000,
"metal": 220000,
"guitar": 21000,
"dark": 2100,
"bass": 190,
"piano": 15
},
"alternative rock": {
"rock": 121000000000,
"metal": 3400000000,
"electro": 330000000,
"electronic": 31000000,
"nu metal": 2500000,
"dark": 230000,
"futuristic": 22000,
"pop": 1600,
"grunge": 150,
"guitar": 14
},
"anime": {
"rock": 24000000000,
"pop": 2300000000,
"piano": 130000000,
"epic": 12000000,
"japanese": 1100000,
"metal": 100000,
"slow": 9000,
"dark": 800,
"electro": 80
},
"dark": {
"synth": 76000000000,
"electro": 7300000000,
"rock": 710000000,
"metal": 68000000,
"pop": 6100000,
"electronic": 500000,
"bass": 48000,
"rap": 4600,
"synthwave": 430,
"drum": 38
},
"synthwave": {
"synth": 213000000000,
"electro": 6000000000,
"dark": 430000000,
"electronic": 37000000,
"pop": 3100000,
"disco": 300000,
"80s": 27000,
"punk": 2400,
"bass": 240,
"beat": 22
},
"catchy": {
"pop": 85000000000,
"guitar": 4400000000,
"metal": 430000000,
"beat": 35000000,
"rock": 3400000,
"bass": 290000,
"rap": 28000,
"epic": 2600,
"electric guitar": 200,
"edm": 19
},
"emo": {
"emotional": 341000000000,
"pop": 12200000000,
"rock": 870000000,
"piano": 49000000,
"rap": 4900000,
"sad": 450000,
"ballad": 45000,
"guitar": 3700,
"synth": 360,
"epic": 34
},
"synth": {
"synthwave": 213000000000,
"pop": 16000000000,
"electro": 1310000000,
"electronic": 90000000,
"dark": 7600000,
"beat": 710000,
"bass": 66000,
"80s": 5400,
"chill": 450,
"punk": 43
},
"80s": {
"pop": 67000000000,
"synth": 5400000000,
"rock": 360000000,
"punk": 28000000,
"synthwave": 2700000,
"powerful": 240000,
"electro": 22000,
"opera": 2200,
"electronic": 210,
"pop rock": 17
},
"electro": {
"electronic": 543000000000,
"pop": 26500000000,
"synth": 1310000000,
"rock": 87000000,
"dark": 7300000,
"swing": 660000,
"electropop": 64000,
"metal": 6400,
"beat": 630,
"bass": 63
},
"electropop": {
"pop": 64000000000,
"electro": 6400000000,
"synth": 80000000,
"rap": 6000000,
"rock": 600000,
"r&b": 50000,
"male vocals": 5000,
"dark": 400,
"synthwave": 40,
"emo": 4
},
"ballad": {
"pop": 81000000000,
"rock": 5100000000,
"emo": 450000000,
"emotional": 40000000,
"piano": 3900000,
"guitar": 240000,
"sad": 23000,
"male voice": 2000,
"acoustic": 140,
"metal": 12
},
"emotional": {
"emo": 341000000000,
"pop": 8500000000,
"rock": 480000000,
"piano": 41000000,
"ballad": 4000000,
"orchestral": 300000,
"sad": 29000,
"epic": 2800,
"rap": 250,
"guitar": 22
},
"country": {
"acoustic": 43000000000,
"pop": 3500000000,
"rock": 340000000,
"beat": 24000000,
"upbeat": 1900000,
"rap": 170000,
"melodic": 15000,
"folk": 1300,
"guitar": 130,
"heartfelt": 11
},
"house": {
"deep": 65000000000,
"techno": 4300000000,
"bass": 420000000,
"electro": 37000000,
"pop": 3200000,
"synth": 290000,
"beat": 26000,
"electronic": 2500,
"funk": 250,
"trance": 24
},
"experimental": {
"rock": 23000000000,
"pop": 2300000000,
"electro": 210000000,
"electronic": 20000000,
"funk": 1900000,
"jazz": 190000,
"soul": 14000,
"guitar": 1300,
"drum": 130,
"bass": 10
},
"industrial": {
"metal": 65000000000,
"rock": 4500000000,
"hard rock": 320000000,
"electro": 27000000,
"synth": 1500000,
"dark": 120000,
"deep": 9000,
"bass": 800,
"pop": 70,
"synthwave": 7
},
"acoustic": {
"guitar": 83000000000,
"pop": 7800000000,
"acoustic guitar": 690000000,
"folk": 57000000,
"country": 4300000,
"indie": 300000,
"piano": 29000,
"melodic": 2600,
"soul": 250,
"rock": 24
},
"powerful": {
"rock": 81000000000,
"metal": 6600000000,
"pop": 490000000,
"guitar": 44000000,
"opera": 4100000,
"drum": 330000,
"bass": 27000,
"epic": 2700,
"80s": 240,
"heavy metal": 24
},
"heartfelt": {
"pop": 19000000000,
"acoustic": 1100000000,
"country": 110000000,
"rock": 10000000,
"emo": 900000,
"soul": 80000,
"melodic": 7000,
"ballad": 600,
"piano": 60,
"beat": 6
},
"acoustic guitar": {
"acoustic": 69000000000,
"guitar": 6900000000,
"piano": 200000000,
"pop": 13000000,
"flute": 900000,
"indie": 90000,
"beat": 9000,
"emo": 800,
"catchy": 70,
"rock": 7
},
"jazz": {
"pop": 59000000000,
"funk": 5800000000,
"rock": 410000000,
"swing": 38000000,
"soul": 3400000,
"electro": 320000,
"bass": 30000,
"rap": 2800,
"smooth": 280,
"blues": 27
},
"funk": {
"pop": 116000000000,
"rock": 8000000000,
"jazz": 580000000,
"bass": 56000000,
"soul": 5300000,
"mutation funk": 520000,
"bounce drop": 48000,
"dubstep": 4500,
"math rock": 430,
"rap": 40
},
"indie": {
"pop": 137000000000,
"rock": 9700000000,
"indie pop": 650000000,
"folk": 34000000,
"punk": 3100000,
"dreamy": 300000,
"acoustic": 30000,
"psychedelic": 2900,
"rap": 210,
"beat": 20
},
"dreamy": {
"pop": 74000000000,
"indie": 3000000000,
"psychedelic": 280000000,
"soul": 18000000,
"synth": 1800000,
"ethereal": 160000,
"funk": 15000,
"rap": 1400,
"emo": 130,
"electro": 13
},
"psychedelic": {
"pop": 42000000000,
"rock": 3300000000,
"soul": 300000000,
"indie": 29000000,
"dreamy": 2800000,
"funk": 230000,
"electro": 17000,
"jazz": 1500,
"electronic": 150,
"synth": 12
},
"indie pop": {
"pop": 65000000000,
"indie": 6500000000,
"rock": 190000000,
"punk": 11000000,
"rap": 1100000,
"dreamy": 100000,
"jazz": 9000,
"funk": 900,
"psychedelic": 90,
"emo": 8
},
"punk": {
"pop": 148000000000,
"rock": 12400000000,
"metal": 510000000,
"synth": 43000000,
"guitar": 4100000,
"bass": 380000,
"rap": 36000,
"electro": 3400,
"dark": 330,
"indie": 31
},
"pop rock": {
"pop": 85000000000,
"rock": 8500000000,
"opera": 170000000,
"80s": 17000000,
"powerful": 1600000,
"punk": 140000,
"metal": 7000,
"ballad": 500,
"indie": 50,
"male voice": 4
},
"mellow": {
"pop": 13000000000,
"lo-fi": 1300000000,
"chill": 120000000,
"slow": 12000000,
"piano": 900000,
"acoustic": 80000,
"jazz": 8000,
"hip hop": 800,
"melodic": 70,
"folk": 6
},
"electronic": {
"electro": 543000000000,
"pop": 16200000000,
"synth": 900000000,
"rock": 58000000,
"beat": 5100000,
"dark": 500000,
"dance": 48000,
"metal": 4600,
"bass": 440,
"synthwave": 37
},
"slow": {
"rock": 41000000000,
"pop": 3900000000,
"guitar": 350000000,
"sad": 32000000,
"dark": 2500000,
"piano": 250000,
"rap": 25000,
"soul": 2500,
"blues": 230,
"bass": 23
},
"ambient": {
"electro": 38000000000,
"electronic": 3300000000,
"techno": 260000000,
"trance": 24000000,
"house": 2200000,
"synth": 200000,
"atmospheric": 18000,
"pop": 1800,
"piano": 170,
"ethereal": 14
},
"piano": {
"pop": 97000000000,
"guitar": 8500000000,
"bass": 660000000,
"drum": 53000000,
"emo": 4900000,
"rock": 480000,
"emotional": 41000,
"sad": 4000,
"ballad": 390,
"violin": 38
},
"grunge": {
"rock": 45000000000,
"guitar": 1800000000,
"metal": 170000000,
"pop": 15000000,
"alternative rock": 1500000,
"melodic": 130000,
"dark": 9000,
"rap": 600,
"hard rock": 60,
"male vocals": 6
},
"k-pop": {
"pop": 120000000000,
"beat": 1400000000,
"bass": 120000000,
"upbeat": 11000000,
"dance": 1000000,
"synth": 90000,
"drum": 9000,
"rock": 800,
"funk": 80,
"dreamy": 7
},
"dance": {
"pop": 145000000000,
"electro": 5800000000,
"electronic": 480000000,
"beat": 36000000,
"bass": 3100000,
"disco": 300000,
"synth": 30000,
"funk": 2900,
"rap": 210,
"house": 20
},
"disco": {
"synth": 43000000000,
"pop": 4000000000,
"funk": 350000000,
"electro": 35000000,
"dance": 3000000,
"synthwave": 300000,
"beat": 20000,
"bass": 1800,
"rock": 150,
"80s": 14
},
"nu metal": {
"metal": 114000000000,
"rock": 5200000000,
"rap": 330000000,
"electro": 30000000,
"electronic": 2600000,
"alternative rock": 250000,
"dark": 22000,
"futuristic": 2200,
"melodic": 220,
"punk": 17
},
"sad": {
"pop": 50000000000,
"emo": 4500000000,
"piano": 400000000,
"guitar": 36000000,
"dark": 3300000,
"slow": 320000,
"emotional": 29000,
"rock": 2900,
"ballad": 230,
"male voice": 22
},
"trap": {
"rap": 327000000000,
"bass": 6000000000,
"pop": 280000000,
"hip hop": 27000000,
"beat": 2500000,
"electro": 180000,
"guitar": 18000,
"emo": 1700,
"aggressive": 170,
"melodic": 16
},
"smooth": {
"jazz": 28000000000,
"pop": 2600000000,
"r&b": 220000000,
"soul": 19000000,
"piano": 1100000,
"beat": 110000,
"bass": 10000,
"funk": 1000,
"guitar": 90,
"catchy": 9
},
"male vocals": {
"female vocals": 151000000000,
"pop": 8600000000,
"rock": 500000000,
"metal": 47000000,
"electro": 4300000,
"bass": 410000,
"synth": 33000,
"rap": 3200,
"emo": 310,
"electronic": 31
},
"female vocals": {
"male vocals": 151000000000,
"pop": 3500000000,
"rock": 270000000,
"bass": 22000000,
"electro": 2200000,
"synth": 190000,
"metal": 19000,
"electronic": 1700,
"guitar": 150,
"emo": 15
},
"upbeat": {
"beat": 366000000000,
"pop": 19700000000,
"electro": 340000000,
"rock": 28000000,
"electronic": 2600000,
"male voice": 220000,
"bass": 22000,
"guitar": 2100,
"rap": 200,
"synth": 19
},
"groovy": {
"funk": 26000000000,
"rock": 2200000000,
"pop": 190000000,
"beat": 11000000,
"bass": 1100000,
"drum": 110000,
"rap": 11000,
"metal": 1000,
"melodic": 90,
"reggae": 7
},
"futuristic": {
"electro": 36000000000,
"electronic": 3500000000,
"dark": 310000000,
"rock": 29000000,
"metal": 2700000,
"alternative rock": 220000,
"nu metal": 22000,
"pop": 1700,
"synth": 170,
"beat": 14
},
"chill": {
"synth": 45000000000,
"pop": 4400000000,
"lo-fi": 350000000,
"electro": 28000000,
"bass": 2500000,
"electronic": 240000,
"jazz": 21000,
"piano": 2000,
"beat": 180,
"house": 17
},
"edm": {
"pop": 58000000000,
"bass": 3800000000,
"rock": 330000000,
"electro": 27000000,
"electronic": 2400000,
"beat": 220000,
"epic": 20000,
"male voice": 2000,
"catchy": 190,
"emo": 19
},
"techno": {
"house": 43000000000,
"trance": 2800000000,
"ambient": 260000000,
"pop": 23000000,
"bass": 1800000,
"punk": 160000,
"guitar": 16000,
"electro": 1600,
"dark": 150,
"rock": 15
},
"cantonese": {
"pop": 27000000000,
"rap": 1900000000,
"male voice": 110000000,
"rock": 7000000,
"dreamy": 700000,
"synth": 50000,
"opera": 4000,
"hip hop": 400,
"drum": 40,
"metal": 4
},
"melancholic": {
"rock": 20000000000,
"emo": 1800000000,
"pop": 150000000,
"acoustic": 15000000,
"sad": 1200000,
"indie": 110000,
"bass": 11000,
"folk": 1100,
"rap": 90,
"synth": 9
},
"gospel": {
"soul": 19000000000,
"uplifting": 1000000000,
"beat": 90000000,
"r&b": 7000000,
"rock": 700000,
"funk": 60000,
"pop": 6000,
"slow": 500,
"blues": 50,
"bass": 5
},
"folk": {
"acoustic": 57000000000,
"rock": 4600000000,
"pop": 350000000,
"indie": 34000000,
"guitar": 3000000,
"metal": 300000,
"drum": 22000,
"male voice": 1800,
"slow": 170,
"dark": 17
},
"deep": {
"bass": 70000000000,
"house": 6500000000,
"male voice": 350000000,
"rap": 29000000,
"beat": 2900000,
"metal": 260000,
"male vocals": 26000,
"pop": 2300,
"electro": 220,
"rock": 22
},
"flute": {
"piano": 25000000000,
"guitar": 2500000000,
"violin": 150000000,
"bass": 15000000,
"drum": 1300000,
"epic": 130000,
"acoustic": 11000,
"folk": 1100,
"fast": 110,
"synth": 10
},
"soul": {
"r&b": 69000000000,
"pop": 6000000000,
"funk": 530000000,
"blues": 48000000,
"rock": 3600000,
"jazz": 340000,
"psychedelic": 30000,
"emo": 2900,
"acoustic": 250,
"slow": 25
},
"blues": {
"soul": 48000000000,
"rock": 3300000000,
"guitar": 270000000,
"jazz": 27000000,
"slow": 2300000,
"acoustic": 190000,
"bass": 15000,
"pop": 1300,
"emo": 120,
"rap": 10
},
"romantic": {
"pop": 46000000000,
"guitar": 1200000000,
"rap": 120000000,
"ballad": 12000000,
"funk": 1000000,
"piano": 100000,
"melodic": 10000,
"experimental": 900,
"violin": 90,
"swing": 9
},
"uplifting": {
"pop": 51000000000,
"rock": 2000000000,
"drum": 150000000,
"bass": 14000000,
"melodic": 1300000,
"piano": 130000,
"hip hop": 11000,
"gospel": 1000,
"guitar": 90,
"epic": 9
},
"progressive": {
"metal": 54000000000,
"rock": 2600000000,
"guitar": 260000000,
"synth": 25000000,
"aggressive": 2200000,
"fast": 210000,
"electro": 20000,
"house": 1900,
"melodic": 180,
"dark": 15
},
"atmospheric": {
"dark": 28000000000,
"piano": 2400000000,
"synth": 230000000,
"electro": 21000000,
"pop": 1900000,
"electronic": 180000,
"ambient": 18000,
"ethereal": 1500,
"cinematic": 140,
"rock": 13
},
"electric guitar": {
"guitar": 120000000000,
"rock": 4400000000,
"metal": 290000000,
"drum": 29000000,
"bass": 2400000,
"catchy": 200000,
"90s": 16000,
"powerful": 1400,
"piano": 120,
"pop": 12
},
"violin": {
"piano": 38000000000,
"guitar": 2900000000,
"bass": 220000000,
"pop": 21000000,
"drum": 1900000,
"edm": 160000,
"beat": 15000,
"male vocals": 1500,
"flute": 150,
"electro": 14
},
"aggressive": {
"metal": 95000000000,
"fast": 6600000000,
"rap": 660000000,
"rock": 39000000,
"guitar": 3400000,
"heavy metal": 280000,
"bass": 27000,
"phonk": 2600,
"progressive": 220,
"pop": 21
},
"fast": {
"aggressive": 66000000000,
"metal": 5700000000,
"rap": 560000000,
"guitar": 45000000,
"rock": 3600000,
"pop": 300000,
"phonk": 29000,
"bass": 2500,
"synth": 230,
"progressive": 21
},
"phonk": {
"fast": 29000000000,
"aggressive": 2600000000,
"bass": 180000000,
"rap": 9000000,
"emo": 900000,
"beat": 90000,
"drum": 8000,
"electro": 800,
"piano": 80,
"deep": 8
},
"vocaloid": {
"pop": 43000000000,
"funk": 3200000000,
"rock": 310000000,
"j-pop": 31000000,
"bass": 2300000,
"math rock": 230000,
"bounce drop": 23000,
"mutation funk": 2300,
"dubstep": 220,
"fast": 17
},
"reggae": {
"beat": 22000000000,
"pop": 1800000000,
"dance": 150000000,
"rap": 14000000,
"upbeat": 1200000,
"electro": 100000,
"melodic": 9000,
"rock": 900,
"acoustic": 80,
"male voice": 7
},
"ethereal": {
"pop": 19000000000,
"dreamy": 1600000000,
"synth": 160000000,
"atmospheric": 15000000,
"ambient": 1400000,
"folk": 130000,
"emo": 12000,
"rock": 1100,
"dark": 100,
"electro": 9
},
"math rock": {
"rock": 60000000000,
"funk": 4300000000,
"mutation funk": 430000000,
"bounce drop": 42000000,
"dubstep": 4100000,
"pop": 370000,
"j-pop": 34000,
"vocaloid": 2300,
"rap": 160,
"edm": 10
},
"female singer": {
"pop": 21000000000,
"synth": 1500000000,
"piano": 140000000,
"electronic": 12000000,
"electro": 1200000,
"synthwave": 100000,
"dark": 10000,
"atmospheric": 1000,
"melodic": 100,
"rock": 10
},
"intense": {
"metal": 38000000000,
"rock": 2400000000,
"epic": 230000000,
"drum": 17000000,
"aggressive": 1600000,
"bass": 150000,
"guitar": 11000,
"fast": 1000,
"heavy metal": 80,
"electro": 8
},
"energetic": {
"pop": 30000000000,
"beat": 2600000000,
"rock": 200000000,
"synth": 19000000,
"upbeat": 1900000,
"electro": 180000,
"electronic": 13000,
"bass": 900,
"guitar": 90,
"drum": 8
},
"swing": {
"electro": 66000000000,
"jazz": 3800000000,
"funk": 270000000,
"guitar": 15000000,
"violin": 1300000,
"fast": 120000,
"bass": 12000,
"rock": 1200,
"lo-fi": 110,
"experimental": 10
},
"anthemic": {
"rock": 33000000000,
"pop": 2100000000,
"emo": 60000000,
"beat": 6000000,
"melodic": 600000,
"male vocals": 50000,
"catchy": 5000,
"classical": 500,
"rap": 40,
"dark": 4
},
"trance": {
"techno": 28000000000,
"house": 2400000000,
"ambient": 240000000,
"pop": 12000000,
"bass": 1100000,
"edm": 90000,
"guitar": 9000,
"fast": 800,
"melodic": 80,
"violin": 7
},
"bounce drop": {
"funk": 48000000000,
"mutation funk": 4800000000,
"dubstep": 430000000,
"rock": 42000000,
"math rock": 4200000,
"pop": 380000,
"j-pop": 33000,
"vocaloid": 2300,
"rap": 160,
"edm": 8
},
"j-pop": {
"pop": 157000000000,
"rock": 5700000000,
"funk": 370000000,
"dubstep": 35000000,
"mutation funk": 3500000,
"math rock": 340000,
"bounce drop": 33000,
"vocaloid": 3100,
"bass": 150,
"upbeat": 15
},
"dubstep": {
"rock": 54000000000,
"pop": 5100000000,
"funk": 450000000,
"mutation funk": 44000000,
"bounce drop": 4300000,
"math rock": 410000,
"j-pop": 35000,
"rap": 3100,
"bass": 310,
"electro": 26
},
"90s": {
"metal": 19000000000,
"guitar": 1800000000,
"catchy": 180000000,
"electric guitar": 16000000,
"rock": 1300000,
"rap": 120000,
"pop": 11000,
"dance": 700,
"soul": 6
},
"classical": {
"piano": 20000000000,
"guitar": 1400000000,
"orchestral": 120000000,
"dark": 11000000,
"rock": 1100000,
"powerful": 90000,
"pop": 8000,
"violin": 800,
"dramatic": 7
},
"mutation funk": {
"funk": 52000000000,
"bounce drop": 4800000000,
"dubstep": 440000000,
"rock": 43000000,
"math rock": 4300000,
"pop": 400000,
"j-pop": 35000,
"vocaloid": 2300,
"rap": 140,
"edm": 10
}
}
}
</file>

<file path="visualizer.py">
# suno-prompt-analyzer/visualizer.py

from typing import Dict, Any
import plotly.graph_objects as go
from pyvis.network import Network
# Match the color from the analyzer for consistency
SECONDARY_NODE_COLOR = "#4682B4"

def create_ranked_bar_chart(data: Dict[str, float], title: str, xaxis_label: str) -> go.Figure:
    """
    Creates a generic horizontal bar chart for ranked data.

    Args:
        data: A dictionary of items and their scores, sorted descending.
        title: The title for the chart.
        xaxis_label: The label for the x-axis.

    Returns:
        A Plotly Figure object ready for rendering.
    """
    # Reverse the data for horizontal bar chart (highest on top)
    if not data:
        return go.Figure().update_layout(title_text=title, annotations=[dict(text="No data available.", showarrow=False)])

    labels = list(data.keys())[::-1]
    values = list(data.values())[::-1]

    fig = go.Figure(go.Bar(
        x=values,
        y=labels,
        orientation='h',
        marker=dict(color=SECONDARY_NODE_COLOR)
    ))

    fig.update_layout(
        title_text=f'<b>{title}</b>',
        xaxis_title=xaxis_label,
        yaxis_title='Associated Styles',
        template='plotly_white',
        height=400,
        margin=dict(l=20, r=20, t=40, b=20),
        showlegend=False,
        yaxis=dict(
            automargin=True
        )
    )

    return fig


def create_association_map(graph_data: Dict[str, Any]) -> Network:
    """
    Creates an interactive force-directed network graph.

    Args:
        graph_data: A dictionary containing 'nodes' and 'edges' lists.

    Returns:
        A Pyvis Network object.
    """
    net = Network(height="600px", width="100%", notebook=True, cdn_resources='in_line')
    
    # Add nodes
    for node in graph_data['nodes']:
        net.add_node(
            n_id=node['id'],
            label=node['label'],
            size=node['size'],
            color=node['color'],
            title=node['title']
        )
    
    # Add edges
    for edge in graph_data['edges']:
        net.add_edge(
            source=edge['from'],
            to=edge['to'],
            value=edge['value'],
            title=edge['title']
        )
    
    # Set physics options for a better layout
    net.set_options("""
    var options = {
      "physics": {
        "barnesHut": {
          "gravitationalConstant": -3000,
          "centralGravity": 0.1,
          "springLength": 150,
          "springConstant": 0.05,
          "damping": 0.09,
          "avoidOverlap": 0.1
        },
        "maxVelocity": 50,
        "minVelocity": 0.1,
        "solver": "barnesHut",
        "stabilization": {
          "enabled": true,
          "iterations": 1000,
          "updateInterval": 25
        }
      }
    }
    """)

    return net
</file>

</files>
